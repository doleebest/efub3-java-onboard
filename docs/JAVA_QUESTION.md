# 자바 핵심 개념 정리
<details>
<summary>Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나요?</summary>
<div markdown="1">
// 내용 입력
byte: 1 바이트
short: 2 바이트
int: 4 바이트
long: 8 바이트
float: 4 바이트
double: 8 바이트
char: 2 바이트
boolean: 1 바이트
=======

- boolean: 1bit
- char: 2byte 
- byte: 1byte
- short: 2byte 
- int: 4byte 
- long: 8byte
- float: 4byte 
- double: 8byte
</div>
</details>
<br>

<details>
<summary>오버라이딩(OverRiding)과 오버로딩(OverLoading)에 대해 설명해주세요.</summary>
<div markdown="1">
// 내용 입력
오버라이딩(Overriding)
오버라이딩은 상위 클래스에서 이미 정의된 메서드를 하위 클래스에서 재정의하는 것을 의미합니다. 
상위 클래스의 메서드 시그니처와 이름, 반환 타입 등이 완전히 일치해야하며, 
메서드 내용을 재정의하여 하위 클래스에서 구현한 내용으로 대체합니다. 
이렇게 하면 상위 클래스의 메서드를 하위 클래스에서 다르게 구현할 수 있으며, 
이를 통해 다형성을 구현할 수 있습니다.

오버로딩(Overloading)
오버로딩은 같은 이름의 메서드를 여러 개 정의하는 것을 의미합니다. 
다만, 이때 메서드 시그니처(매개변수의 타입, 개수, 순서)가 서로 달라야 합니다.
메서드 이름은 같지만 메서드 시그니처가 다르기 때문에, 컴파일러는 어떤 메서드를 호출해야 하는지 구분할 수 있습니다. 
오버로딩을 통해 메서드 이름을 일관되게 유지하면서, 같은 기능을 하는 메서드를 다양한 상황에 대해 제공할 수 있습니다.

- 오버라이딩: 서브 클래스에서 슈퍼 클래스에 있는 메소드와 동일한 이름의 메소르를 재작성하는 것. 메소드의 이름, 인자의 타입, 개수, 리턴 타입 등이 모두 동일해야 한다. 
실행 시간에 오버라이딩된 메소드를 찾아 호출하는 동적 바인딩 방식이다.
- 오버로딩: 같은 클래스나 상속 관계에서 동일한 이름의 메소드를 중복으로 작성하는 것. 메소드 이름은 동일하나, 인자의 개수나 타입이 달라야 한다.
컴파일 시에 중복된 메소드 중 호출되는 메소드를 결정하는 정적 바인딩 방식이다.

</div>
</details>
<br>

<details>
<summary>객체지향 프로그래밍(OOP)에 대해 설명해주세요</summary>
<div markdown="1">
// 내용 입력
객체 지향 프로그래밍 이란, 많은 객체(Objcet)들이 모여서 
상호 협력하면서 데이터를 처리하는 방식의 프로그래밍 설계 방법을 일컫는다. 
좀더 쉽게 말하면, 프로그램을 묶음 단위로 잘게 쪼개서, 
추후에 가져다 쓰기 편하게 만들어 놓은 프로그래밍 방식이라고 보면 됩니다.

데이터(ex. 필드)와 기능(ex. 메소드)을 하나로 묶어놓은 것을 객체라고 하는데, 
컴퓨터가 수행하는 작업을 객체 간의 상호작용으로 표현하고, 클래스 혹은 객체들의 집합으로 프로그램을 작성하는 것이 객체지향 프로그래밍이다. <br>
객체지향 프로그래밍의 특징은 캡슐화, 상속, 다형성이다. 
캡슐화는 불필요한 정보의 노출을 최소화하고 꼭 필요한 정보만 노출하는 기법으로, 객체를 외부의 접근으로부터 보호하기 위해 사용된다. 
상속은 새로운 객체를 정의할 때, 기존 객체를 재사용하는 용도로 사용된다. 하위 객체가 상위 객체의 속성과 메소르를 모두 사용할 수 있으며, 필요 시 상위 객체의 메소드를 재정의할 수 있다.
다형성은 같은 이름의 메소드가 클래스나 객체에 따라 다르게 동작하도록 구현하는 것이다. 메소드 오버로딩과 메소드 오버라이딩은 다형성을 구현한다.

</div>
</details>
<br>

<details>
<summary>추상 클래스와 인터페이스에 대해 설명해주시고, 차이에 대해 설명해주세요.</summary>
<div markdown="1">
// 내용 입력
추상클래스란?
추상클래스는 일반 클래스와 별 다를 것이 없습니다. 단지, 추상 메서드를 선언하여 상속을 통해서 자손 클래스에서 완성하도록 유도하는 클래스입니다. 그래서 미완성 설계도라고도 표현합니다. 상속을 위한 클래스이기 때문에 따로 객체를 생성할 수 없습니다.
class 앞에 "abstract" 예약어를 사용하여 상속을 통해서 구현해야한다는 것을 알려주고 선언부만 작성하는 추상메서드를 선언할 수 있습니다.

인터페이스란?
추상클래스가 미완성 설계도라면 인터페이스는 기본 설계도라고 할 수 있습니다. 인터페이스도 추상클래스처럼 다른 클래스를 작성하는데 도움을 주는 목적으로 작성하고 클래스와 다르게 다중상속(구현)이 가능합니다.

차이점
차이점으로는 추상 클래스는 extends 키워드를 사용하여 상속하며, 다중 상속은 불가능합니다. 반면 인터페이스는 implements 키워드를 사용하여 상속하며, 다중 상속이 가능합니다.


- 추상 클래스: abstract로 선언된 클래스로, 상속을 위한 슈퍼클래스로 활용된다. 추상 메소드를 가지면 반드시 abstract로 선언해야 한다. 추상 클래스는 온전한 클래스가 아니므로 인스턴스를 생성할 수 없다.
- 인터페이스: 클래스가 구현해야 할 메소드들이 선언되는 것. 인터페이스에는 필드를 선언할 수 없다. 인터페이스 구현 시 implements 키워드를 사용하고, 인터페이스 간 상속 시 extends 키워드를 사용한다. 
- 차이: 추상 클래스는 다중 상속이 불가하나, 인터페이스는 다중 상속이 가능하다.

</div>
</details>
<br>

<details>
<summary>가비지 컬렉션(gc)란 무엇일까요?</summary>
<div markdown="1">
// 내용 입력
메모리 관리 기법 중의 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능이다.
가리키는 레퍼런스가 하나도 없는 객체인 가비지를 JVM의 가비지 컬렉터가 자동으로 수집한 것을 가비지 컬렉션이라고 한다. 
</div>
</details>
<br>

<details>
<summary>JVM의 동작 방식에 대해 설명해 주세요.</summary>
<div markdown="1">
// 내용 입력
VM이란 JVM은 자바 가상머신으로 자바 바이트코드를 실행 할 수 있는 주체로 JVM 덕분에 CPU나 플랫폼(OS+CPU아키텍처)과 독릭접으로 동작 가능하다. 
예를들어 리눅스에서 컴파일한 C프로그램을 윈도우에서 실행했을때 환경이 달라서 작동하지 않는다는 문제가 있다고 한다.
소스 파일(.java)을 컴파일하면 클래스 파일(.class)이 생성된다. 
클래스 파일은 JVM에서 실행 가능한 바이너리 코드인 바이트 코드로 이루어져 있고, 
JVM이 인터프리터 방식으로 바이트 코드를 해석하여 실행한다.
</div>
</details>
<br>

<details>
<summary>불변 객체란 무엇이고, final은 무엇일까요? 사용하는 이유와 함께 설명해주세요.</summary>
<div markdown="1">
// 내용 입력
불변 객체(Immutable Object)란, 생성 후 내부 상태를 변경할 수 없는 객체를 말합니다. 
즉, 한 번 생성된 후에는 그 상태가 변경되지 않으며, 새로운 상태를 갖는 새로운 객체를 생성해 반환하는 방식으로 동작합니다. 
불변 객체는 다른 객체와 공유하거나 여러 스레드에서 안전하게 사용할 수 있습니다. 
final은 변수, 메서드, 클래스 앞에 사용되어 해당 요소가 변경될 수 없다는 것을 나타내는 예약어입니다. 
final로 선언된 변수는 값이 한 번만 할당될 수 있으며, 
final로 선언된 메서드와 클래스는 상속되거나 오버라이드될 수 없습니다.
따라서, 불변 객체와 final은 모두 객체 안정성과 코드 안정성을 보장하기 위한 방법입니다. 
불변 객체는 내부 상태가 변경될 수 없는 객체를 말하며, final은 값이 변경될 수 없는 변수나 메서드, 클래스를 말합니다. 
이들은 다른 객체와 공유하거나 여러 스레드에서 안전하게 사용할 수 있도록 만들어줍니다.

- 불변 객체: 생성 후 그 상태를 바꿀 수 없는 객체로, 복제나 비교를 위한 조작을 단순화하거나 성능을 개선하기 위해 사용된다.
- final
  - 클래스 앞에 붙을 때: 이 클래스를 상속받을 수 없게 한다. 
  - 메소드 앞에 붙을 때: 이 메소드를 오버라이딩하지 못하게 막는 역할을 한다.
  - 필드 앞에 붙을 때: 상수를 선언하는 데 사용한다. 상수 필드는 한 번 초기화되면 값을 변경할 수 없다.

</div>
</details>
<br>

<details>
<summary>자바의 메모리 영역에 대해 설명해주세요.</summary>
<div markdown="1">
// 내용 입력
메서드 영역 (Method Area)
JVM이 시작할 때 생성되며, 클래스 파일들의 바이트코드를 저장하는 곳입니다.
모든 스레드가 공유하며, 클래스 로더가 클래스를 읽어들일 때마다 클래스 정보를 저장합니다.
상수 풀(Constant Pool)도 이 영역에 포함됩니다.

힙 영역 (Heap)
객체와 배열이 저장되는 곳입니다.
런타임 시 동적으로 할당되며, GC(Garbage Collector)가 관리합니다.
두 개 이상의 스레드가 동시에 접근할 수 있습니다.

스택 영역 (Stack)
각 스레드마다 존재하는 공간으로, 스레드가 생성될 때마다 생성됩니다.
메서드를 호출할 때마다 호출된 메서드와 관련된 지역 변수, 매개 변수, 리턴 값, 연산 중간 결과값 등을 저장합니다.
메서드가 종료되면 해당 메서드가 사용한 스택 프레임(Stack Frame)이 제거됩니다.

PC(Program Counter) 레지스터 영역
각 스레드마다 존재하는 공간으로, 현재 수행 중인 JVM 명령의 주소를 저장합니다.
스레드가 실행 중인 부분이 어디인지를 가리킵니다.

네이티브 메서드 스택 영역
자바 외부에서 실행되는 네이티브 코드(C/C++ 등)를 위한 스택 영역입니다.
JVM은 자바 코드에서 네이티브 메서드를 호출할 때, 이 영역을 사용합니다.

- 메소드 영역: JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 메서드 정보, static 변수, 메소드의 바이트코드가 할당된다.
- 힙 영역: 인스턴스 또는 객체를 저장하며, 가비지 컬렉션 대상으로 JVM 성능에 대한 이슈에 가장 많이 언급되는 영역
- 스택 영역: 메소드 호출 시에 생성되며 종료 시에 같이 제거된다. 지역변수, 매개변수, 리턴값, 참조변수 등이 저장된다.
- PC레지스터: 각 스레드마다 하나씩 존재하며, 스레드 시작 시에 생성, JVM이 수행할 명령어의 주소를 저장하는 영역
- Native 메소드 스택: Java Native Interface 호출 및 종료 시 생성되며, 바이트코드가 아닌 기계어로 작성된 코드를 실행하는 영역

</div>
</details>
<br>

<details>
<summary>new String()과 리터럴(" ")의 차이에 대해 설명해주세요.</summary>
<div markdown="1">
// 내용 입력
new String()

Heap 메모리에 새로운 객체를 생성합니다.
매번 새로운 객체가 생성되므로, 메모리 사용량이 증가합니다.
equals() 메서드로 문자열을 비교할 경우, 문자열의 내용이 같아도 다른 객체로 인식됩니다.
리터럴(" ")

String Pool 메모리 영역에 이미 존재하는 문자열 객체를 참조합니다.
같은 문자열을 갖는 객체가 여러 개 생성되지 않고, 메모리를 절약할 수 있습니다.
equals() 메서드로 문자열을 비교할 경우, 문자열의 내용이 같으면 같은 객체로 인식됩니다.
따라서, new String()을 사용하면 새로운 객체를 생성하므로 메모리 사용량이 증가하게 됩니다. 이는 성능에도 영향을 미칠 수 있습니다. 반면에, 리터럴을 사용하면 이미 생성된 문자열 객체를 참조하므로 메모리 사용량을 줄일 수 있습니다. 그러나 문자열이 계속해서 바뀌는 경우에는 새로운 객체를 생성해야 하므로, 
이 경우에는 new String()을 사용하는 것이 더 적절할 수 있습니다.

문자열 리터럴은 자바 내부에서 리터럴 테이블로 특별히 관리하며, 문자열 생성에 대한 실행 시간을 줄이기 위해 동일한 리터럴은 공유시킨다. 
<br>반면, new String()에 의해 생성된 문자열은 힙 메모리에 별도로 생성된다. 또한, 일단 생성된 문자열 객체는 수정이 불가능하다. 

</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 람다(lambda)에 대해 알아볼까요?</summary>
<div markdown="1">
// 내용 입력
람다(lambda)는 자바 8부터 지원하는 함수형 프로그래밍 기법으로, 코드의 간결성과 가독성을 높여줍니다. 
람다식은 익명 함수(anonymous function)를 만들어내는 것으로, 
메서드를 하나의 식으로 표현할 수 있습니다.
다음과 같이 표현 : (매개변수) -> { 실행 코드 }
람다식은 이름 없는 함수로, 수학의 함수를 단순하게 표현하는 방법이다.

`f(x, y) = x + y`를 수학의 람다식으로 바꾸면, `(x, y) -> x + y`가 된다.

괄호와 함께 x, y에 대입될 값을 지정하면 람다식의 계산이 이루어진다.
```agsl
((x, y) -> x + y)(2, 3)
= 2 + 3
= 5
```
---
자바에서 람다식은 매개변수 리스트, 애로우 토큰, 함수 바디의 3부분으로 작성된다.

`(  매개변수 리스트  ) -> {  함수 바디  }`
- 매개변수 리스트: 함수에 전달되는 매개변수들이 나열되며, 매개변수를 생략하면 컴파일러가 추론 기능을 이용하여 알아서 처리한다.
- 애로우 토큰(->): 매개변수 리스트와 함수 코드를 분리시키는 역할
- 함수 바디: 함수의 코드를 작성하는 부분
</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 스트림(stream)에 대해 알아볼까요?</summary>
<div markdown="1">
// 내용 입력
자바 8부터 도입된 스트림(Stream)은 컬렉션(Collection)의 요소를 하나씩 참조하여 람다식으로 처리할 수 있도록 해주는 기능입니다. 스트림은 데이터를 처리하는데 필요한 연산들을 지원하며, 이를 이용하여 간결하고 가독성이 높은 코드를 작성할 수 있습니다.

스트림은 다음과 같은 특징을 가지고 있습니다.

데이터 소스로부터 데이터를 읽기만 할 뿐 변경하지 않습니다. (불변성)
스트림 연산은 중간 연산과 최종 연산으로 구분됩니다.
지연 연산이 가능합니다. (즉, 최종 연산을 수행하기 전까지 중간 연산이 수행되지 않습니다.)

입출력 스트림은 응용프로그램과 입출력 장치를 연결하는 소프트웨어 모듈로서, 입출력 장치와 응용프로그램 사이에서 데이터가 순서대로 전송되도록 한다. 
<br>입출력 스트림은 문자 스트림과 바이트 스트림의 2종류로 나뉘며, 문자 스트림은 문자만 다룰 수 있고, 바이트 스트림은 스트림에 들어오고 나가는 정보를 바이너리로 다루기 때문에 문자이든 이미지 바이트이든 상관없이 흘려보낸다.

</div>
</details>
<br>

